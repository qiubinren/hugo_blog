---
title: "移植C++程序常见coredump与调试方法"
date: 2018-07-27T09:19:15+08:00
draft: false
tags: ["Cpp", "Java", "Coredump"]
categories: ["Cpp", "Java", "Coredump"]
---

# 移植C++程序常见coredump与调试方法

## 移植C++程序的大坑

还是[JavaCpp混合编程 Swig的使用](https://www.qiubinren.com/2017-10-06-javacpp混合编程-swig的使用.html)这篇博客里介绍的项目，云化系统动态库部分仍然是老`AIX`平台上的源码，迁移到`X86`上之后，各种出问题，各种姿势`coredump`，各种内存泄漏，经过反复排查，修改了大量代码，总算稳定下来了，深深理解了跨平台迁移`c++`程序真的是一个大坑。这边总结下使用的调试方法和工具。

<!--more-->

## 平台编译器差异导致的问题

首先是平台差异导致的`coredump`，在`AIX`上跑了十年的动态库，一旦迁移了平台，编译器差异导致很多不规范的写法，不再可行。

比如`Xlc`编译器直接对`string`赋值`null`，编译运行都没有问题，老代码中埋的一些这类坑，在`AIX`上并不会爆炸，但是一旦迁移到`X86`用`gcc`编译后，就直接爆炸了，编译没问题，运行到那边直接`coredump`。

老代码：

``` c++
int  HttpCall::transfer_post_async(const char* url, const char* formValues, int timeout,string& o_data,bool need_escape/* = false*/)
{
  ...
  char *buf = NULL;
  ...
  buf = ghttp_get_body(request);
  o_data = buf;
  ...
}
```

这边对 buf的返回值没有为`NULL`保护，直接赋值给了`o_data`，导致某些逻辑下`string`直接被`NULL`赋值，`gcc`编译阶段不会报错，运行时直接`coredump`。

加入保护后解决:

``` c++
buf = ghttp_get_body(request);
o_data = buf == NULL ? "" : buf;
```

这类错误比较明显，`gdb`分析`coredump`，查看堆栈，直接就能发现`coredump`的位置，分析代码即可。

写个测试模拟下，`a.cpp`:

``` c++
#include <iostream>
using namespace std;

int main()
{
        char *buf = NULL;
        string o_data;
        o_data = buf;
        return 0;
}
```

编译运行（编译时加入`-g`参数方便后面查看堆栈）：

```shel
g++ a.cpp -g
./a.out 
Segmentation fault (core dumped)
```

发现`coredump`，生成了个`coredump`文件

``` shell
ls
a.cpp  a.out  core.25243
```

如果没有生成`coredump`文件，检查主机`ulimit -a`参数:

```shell
ulimit -a
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 63691
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65536
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 16384
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

如果`core file size          (blocks, -c) unlimited`不是`unlimited`，使用下面命令修改成`unlimited`

``` shell
ulimit -c unlimited
```

有了`coredump`文件，调试这类错误就很简单了，`gdb`查看。

``` shell
gdb a.out core.25243 

GNU gdb (GDB) Red Hat Enterprise Linux (7.2-90.el6)
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /home/disk01/svn/xuqiangxia/trunk/BOSSX86/SourceCode/SPS/src/app/OperationProcess/src/ne/test/a.out...done.
[New Thread 25243]
Missing separate debuginfo for 
Try: yum --enablerepo='*-debug*' install /usr/lib/debug/.build-id/ec/37397b4ecc9f347891ceff84a05131bf10bfc3
Reading symbols from /usr/lib64/libstdc++.so.6...(no debugging symbols found)...done.
Loaded symbols for /usr/lib64/libstdc++.so.6
Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libgcc_s.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib64/libgcc_s.so.1
Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Core was generated by `./a.out'.
Program terminated with signal 11, Segmentation fault.
#0  0x000000398253382f in __strlen_sse42 () from /lib64/libc.so.6
Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.192.el6.x86_64 libgcc-4.4.7-17.el6.x86_64 libstdc++-4.4.7-17.el6.x86_64

(gdb) where
#0  0x000000398253382f in __strlen_sse42 () from /lib64/libc.so.6
#1  0x000000398d89e14c in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(char const*) () from /usr/lib64/libstdc++.so.6
#2  0x0000000000400836 in main () at a.cpp:8
```

很明显，告诉我们`a.cpp`第8行`core`了，分析第8行代码，即可分析出这边是给`string`赋值为`NULL`导致的问题。

## 线程不安全的系统调用

由于项目架构的变化，动态库调用上与以前有很大的不同，这边体现为以前是多进程模型，现在变成了多线程模型（埋坑）。

以前的进程模型:

![p1](/img/2018-07-27-p2.png)

现在的进程模型:

![p2](/img/2018-07-27-p1.png)

这边其实为后续的一些`coredump`埋下深坑，以前分成多个进程的job，变成了单进程多线程，并发量又非常大，动态库中一些线程不安全的系统调用开始频繁`coredump`。

比如`gdb`分析`core`文件定位到的代码：

``` c++
		string sSource ,sReplace;  
	  time_t now;  
    struct tm tmNow;  
	  now = time(NULL);  
    tmNow = *localtime(&now);  

    sprintf(cBuf,"%04d%02d%02d%02d%02d%02d",  
    tmNow.tm_year+1900,tmNow.tm_mon+1,  
    tmNow.tm_mday,tmNow.tm_hour,  
    tmNow.tm_min,tmNow.tm_sec);  
```

系统函数`localtime`不是线程安全的，同样发现代码中有类似问题的还有`gethostbyname`函数。

```c++
		if( (nameinfo = gethostbyname( host )) == NULL )
    {
        addr.sin_addr.s_addr = inet_addr( host );
        if( (int)addr.sin_addr.s_addr == -1 )
        {
            hResponse.iError = errno;
            hResponse.pError = strerror( errno );

            fprintf( stderr, "Unknown host %s\n", host );
            if( pBuf ) free( pBuf );
            if( pRequest ) free( pRequest );
            return( hResponse );
        }
    }
    else
    {
        memcpy( (char *)&addr.sin_addr.s_addr, nameinfo->h_addr, nameinfo->h_length );
    }
```

动态库中大量使用了这些线程不安全的系统调用，以前单进程模型不会触发此类问题，现在进程模型变成了多线程模型，直接导致生产进程不断`coredump`。

将使用的系统调用改为线程安全版本即可，这边分别改为使用`localtime_r()`和`gethostbyname_r()`即可。

## 内存泄露问题分析神器----Valgrind

进程上线生产之后，`jdk`堆外内存越来越大，跑了十天半个月之后就会定期`core`一次，`gdb`查看每次`coredump`的位置不一样，难以定位具体位置，怀疑老代码里就有内存泄漏问题，多个`job`变成多线程合在同一进程中，加剧了内存泄漏。

这边推荐使用`Valgrind`来分析内存泄漏问题，一个很好用的内存分析工具。

有个插曲，因为我们的进程入口其实是`java`，`Valgrind`无法对`jdk`进行内存分析，运行之后往往还没进动态库，就误报内存泄露导致进程终止。所以想要分析动态库内的内存泄漏问题，我们还额外写个入口来测试，这边不详细介绍，这边主要简单介绍`Valgrind`，项目中以后遇到此类问题都可借助这个工具分析。

> **Valgrind 命令介绍：**
>
> **用法: valgrind [options] prog-and-args** 
>
> --tool=<name> 最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。
>
> --memcheck ------> 这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。
>
> --callgrind ------> 它主要用来检查程序中函数调用过程中出现的问题。
>
> --cachegrind ------> 它主要用来检查程序中缓存使用出现的问题。
>
> --helgrind ------> 它主要用来检查多线程程序中出现的竞争问题。
>
> --massif ------> 它主要用来检查程序中堆栈使用中出现的问题。
>
> --extension ------> 可以利用core提供的功能，自己编写特定的内存调试工具。
>
> -h –help 显示帮助信息。
>
> -version 显示valgrind内核的版本，每个工具都有各自的版本。
>
> -q –quiet 安静地运行，只打印错误信息。
>
> -v –verbose 更详细的信息, 增加错误数统计。
>
> -trace-children=no|yes 跟踪子线程? [no]
>
> -track-fds=no|yes 跟踪打开的文件描述？[no]
>
> -time-stamp=no|yes 增加时间戳到LOG信息? [no]
>
> -log-fd=<number> 输出LOG到描述符文件 [2=stderr]
>
> -log-file=<file> 将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID
>
> -log-file-exactly=<file> 输出LOG信息到 file
>
> -log-file-qualifier=<VAR> 取得环境变量的值来做为输出信息的文件名。 [none]
>
> -log-socket=ipaddr:port 输出LOG到socket ，ipaddr:port
>
> **LOG信息输出**
>
> -xml=yes 将信息以xml格式输出，只有memcheck可用
>
> -num-callers=<number> show <number> callers in stack traces [12]
>
> -error-limit=no|yes 如果太多错误，则停止显示新错误? [yes]
>
> -error-exitcode=<number> 如果发现错误则返回错误代码 [0=disable]
>
> -db-attach=no|yes 当出现错误，valgrind会自动启动调试器gdb。[no]
>
> -db-command=<command> 启动调试器的命令行选项[gdb -nw %f %p]
>
> **适用于Memcheck工具的相关选项：**
>
> -leak-check=no|summary|full 要求对leak给出详细信息? [summary]
>
> -leak-resolution=low|med|high how much bt merging in leak check [low]
>
> -show-reachable=no|yes show reachable blocks in leak check? [no]

最常用的命令格式：

```shel
valgrind --tool=memcheck --leak-check=full ./test 
```

写个简单的例子演示一下使用，`a.cpp`代码:

``` c++
#include <iostream>
using namespace std;
int main()
{
        int *a = new int(2);

        //delete a;

        return 0;
}
```

编译：

``` shell
g++ -g a.cpp
```

使用`valgrind`工具运行进程：

``` shell
valgrind --tool=memcheck --leak-check=full ./a.out

==22442== Memcheck, a memory error detector
==22442== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==22442== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==22442== Command: ./a.out
==22442== 
==22442== 
==22442== HEAP SUMMARY:
==22442==     in use at exit: 4 bytes in 1 blocks
==22442==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated
==22442== 
==22442== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==22442==    at 0x4A075FC: operator new(unsigned long) (vg_replace_malloc.c:298)
==22442==    by 0x4006D5: main (a.cpp:5)
==22442== 
==22442== LEAK SUMMARY:
==22442==    definitely lost: 4 bytes in 1 blocks
==22442==    indirectly lost: 0 bytes in 0 blocks
==22442==      possibly lost: 0 bytes in 0 blocks
==22442==    still reachable: 0 bytes in 0 blocks
==22442==         suppressed: 0 bytes in 0 blocks
==22442== 
==22442== For counts of detected and suppressed errors, rerun with: -v
==22442== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 6 from 6)
```

发现输出结果里面有报错，告诉你第5行`by 0x4006D5: main (a.cpp:5)`有内存泄露。

`Memcheck`将内存泄露分为两种，一种是可能的内存泄露（`Possibly lost`），另外一种是确定的内存泄露（`Definitely lost`）。`Possibly lost`是指仍然存在某个指针能够访问某块内存，但该指针指向的已经不是该内存首地址。`Definitely lost`是指已经不能够访问这块内存。而`Definitely lost`又分为两种：直接的（`direct`）和间接的（`indirect`）。直接和间接的区别就是，直接是没有任何指针指向该内存，间接是指指向该内存的指针都位于内存泄露处。在上述的例子中，根节点是`directly lost`，而其他节点是`indirectly lost`。

内存检查原理:

![p3](/img/2018-07-27-p3.png)

![p4](/img/2018-07-27-p4.png)

![p5](/img/2018-07-27-p5.png)

